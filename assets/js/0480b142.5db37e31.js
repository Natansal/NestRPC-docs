"use strict";(self.webpackChunknestjs_rpc_docs=self.webpackChunknestjs_rpc_docs||[]).push([[70],{7208:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"faq","title":"FAQ","description":"Frequently asked questions about NestRPC. Type inference, file uploads, custom decorators, and more.","source":"@site/docs/faq.md","sourceDirName":".","slug":"/faq","permalink":"/NestRPC-docs/docs/faq","draft":false,"unlisted":false,"editUrl":"https://github.com/Natansal/NestRPC-docs/blob/main/docs/faq.md","tags":[],"version":"current","frontMatter":{"title":"FAQ","description":"Frequently asked questions about NestRPC. Type inference, file uploads, custom decorators, and more."},"sidebar":"tutorialSidebar","previous":{"title":"Advanced Features","permalink":"/NestRPC-docs/docs/query/advanced"}}');var t=r(4848),i=r(8453);const o={title:"FAQ",description:"Frequently asked questions about NestRPC. Type inference, file uploads, custom decorators, and more."},l="Frequently Asked Questions",c={},a=[{value:"\ud83d\udd12 Type Safety",id:"-type-safety",level:2},{value:"How are input types inferred on the client?",id:"how-are-input-types-inferred-on-the-client",level:3},{value:"Can I decorate the first parameter?",id:"can-i-decorate-the-first-parameter",level:3},{value:"How do I access the Nest request/response?",id:"how-do-i-access-the-nest-requestresponse",level:3},{value:"\ud83d\udce4 File Uploads",id:"-file-uploads",level:2},{value:"How do file uploads work?",id:"how-do-file-uploads-work",level:3},{value:"Can I set file size limits?",id:"can-i-set-file-size-limits",level:3},{value:"Can I filter file types?",id:"can-i-filter-file-types",level:3},{value:"\ud83c\udfa8 Routers as Controllers",id:"-routers-as-controllers",level:2},{value:"Are routers NestJS controllers?",id:"are-routers-nestjs-controllers",level:3},{value:"Do I need to register routers in the module?",id:"do-i-need-to-register-routers-in-the-module",level:3},{value:"\ud83c\udfa8 Custom Decorators",id:"-custom-decorators",level:2},{value:"Can I create custom parameter decorators?",id:"can-i-create-custom-parameter-decorators",level:3},{value:"\ud83d\udcbb Client Configuration",id:"-client-configuration",level:2},{value:"Should I import the manifest object or just the type?",id:"should-i-import-the-manifest-object-or-just-the-type",level:3},{value:"\u2699\ufe0f Configuration",id:"\ufe0f-configuration",level:2},{value:"How do I change the API prefix?",id:"how-do-i-change-the-api-prefix",level:3},{value:"Can I use different base URLs for different environments?",id:"can-i-use-different-base-urls-for-different-environments",level:3},{value:"Can I update the client configuration at runtime?",id:"can-i-update-the-client-configuration-at-runtime",level:3},{value:"\ud83d\udd27 NestJS Integration",id:"-nestjs-integration",level:2},{value:"Do routers work with NestJS dependency injection?",id:"do-routers-work-with-nestjs-dependency-injection",level:3},{value:"Can I use guards, interceptors, and pipes?",id:"can-i-use-guards-interceptors-and-pipes",level:3},{value:"Why must <code>nestRpcInit()</code> be called before <code>NestFactory.create()</code>?",id:"why-must-nestrpcinit-be-called-before-nestfactorycreate",level:3},{value:"\u269b\ufe0f React Query Integration",id:"\ufe0f-react-query-integration",level:2},{value:"Should I use React Query or direct RPC calls?",id:"should-i-use-react-query-or-direct-rpc-calls",level:3},{value:"How do I set up React Query with NestRPC?",id:"how-do-i-set-up-react-query-with-nestrpc",level:3},{value:"How does automatic cache invalidation work?",id:"how-does-automatic-cache-invalidation-work",level:3},{value:"Can I use file uploads with React Query mutations?",id:"can-i-use-file-uploads-with-react-query-mutations",level:3},{value:"How do I manually invalidate queries?",id:"how-do-i-manually-invalidate-queries",level:3},{value:"\ud83d\udc1b Troubleshooting",id:"-troubleshooting",level:2},{value:"Routes are not being registered",id:"routes-are-not-being-registered",level:3},{value:"Type inference not working on client",id:"type-inference-not-working-on-client",level:3},{value:"File uploads not working",id:"file-uploads-not-working",level:3},{value:"CORS errors",id:"cors-errors",level:3},{value:"\ud83d\udcda Further Reading",id:"-further-reading",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"frequently-asked-questions",children:"Frequently Asked Questions"})}),"\n",(0,t.jsx)(n.h2,{id:"-type-safety",children:"\ud83d\udd12 Type Safety"}),"\n",(0,t.jsx)(n.h3,{id:"how-are-input-types-inferred-on-the-client",children:"How are input types inferred on the client?"}),"\n",(0,t.jsxs)(n.p,{children:["The first parameter of each ",(0,t.jsx)(n.code,{children:"@Route()"})," method is treated as the input type. Export ",(0,t.jsx)(n.code,{children:"type Manifest = typeof manifest"})," on the server and use ",(0,t.jsx)(n.code,{children:"new RpcClient<Manifest>()"})," on the client:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Server\n@Route()\nasync getUserById(id: string) {\n  return { id, name: 'John' };\n}\n\n// Client - id is automatically typed as string\nconst { data } = await rpc.user.getUserById('123');\n"})}),"\n",(0,t.jsx)(n.h3,{id:"can-i-decorate-the-first-parameter",children:"Can I decorate the first parameter?"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"No."})," The first parameter (index 0) is reserved for the incoming request body and should be left undecorated. The first parameter's type flows to the client automatically. If the route has file upload configuration, the second parameter is reserved for the file/files:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Correct\n@Route()\nasync getUserById(id: string) {\n  return getUser(id);\n}\n\n// \u274c Incorrect - don't decorate first parameter\n@Route()\nasync getUserById(@Body() id: string) {\n  return getUser(id);\n}\n\n// \u2705 Correct - decorate subsequent parameters\n@Route()\nasync getUserById(\n  id: string, // \u2705 First param = request body (no decorator)\n  @Req() req: Request, // \u2705 Can decorate subsequent params\n) {\n  return getUser(id);\n}\n\n// \u2705 With file upload - first param = body, second param = file\n@Route({ file: 'single' })\nasync uploadFile(\n  { description }: { description?: string }, // \u2705 First param = request body\n  file?: Express.Multer.File, // \u2705 Second param = file (when file config is set)\n  @Req() req: Request, // \u2705 Subsequent params can use decorators\n) {\n  return { filename: file?.originalname };\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"how-do-i-access-the-nest-requestresponse",children:"How do I access the Nest request/response?"}),"\n",(0,t.jsx)(n.p,{children:"Use standard Nest request/response access patterns inside your router methods or global interceptors/guards:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { Req, Res } from '@nestjs/common';\nimport type { Request, Response } from 'express';\n\n@Router()\nexport class UserRouter {\n  @Route()\n  async getUserById(\n    id: string,\n    @Req() req: Request,\n    @Res() res: Response,\n  ) {\n    // Access request properties\n    const ip = req.ip;\n    const headers = req.headers;\n    \n    // Access response\n    res.setHeader('X-Custom-Header', 'value');\n    \n    return getUser(id);\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"-file-uploads",children:"\ud83d\udce4 File Uploads"}),"\n",(0,t.jsx)(n.h3,{id:"how-do-file-uploads-work",children:"How do file uploads work?"}),"\n",(0,t.jsxs)(n.p,{children:["NestRPC has built-in file upload support. Use the ",(0,t.jsx)(n.code,{children:"file"})," option in ",(0,t.jsx)(n.code,{children:"@Route()"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Single file\n@Route({ file: 'single' })\nasync uploadFile(\n  { description }: { description?: string },\n  file?: Express.Multer.File\n) {\n  // Handle file\n}\n\n// Multiple files\n@Route({ file: 'multiple' })\nasync uploadFiles(\n  { category }: { category?: string },\n  files?: Express.Multer.File[]\n) {\n  // Handle files\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"On the client, pass files in the second parameter:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Single file\nawait rpc.files.uploadFile(\n  { description: 'Avatar' },\n  { file: myFile }\n);\n\n// Multiple files\nawait rpc.files.uploadFiles(\n  { category: 'documents' },\n  { files: [file1, file2] }\n);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{href:"/docs/server/file-uploads",children:"Server File Uploads"})," and ",(0,t.jsx)(n.a,{href:"/docs/client/file-uploads",children:"Client File Uploads"})," for details."]}),"\n",(0,t.jsx)(n.h3,{id:"can-i-set-file-size-limits",children:"Can I set file size limits?"}),"\n",(0,t.jsx)(n.p,{children:"Yes, use the advanced file configuration:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@Route({\n  file: {\n    mode: 'single',\n    options: {\n      limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit\n    },\n  },\n})\nasync uploadFile({}, file?: Express.Multer.File) {\n  // Handle file\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"can-i-filter-file-types",children:"Can I filter file types?"}),"\n",(0,t.jsxs)(n.p,{children:["Yes, use ",(0,t.jsx)(n.code,{children:"fileFilter"})," in the options:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@Route({\n  file: {\n    mode: 'single',\n    options: {\n      fileFilter: (req, file, cb) => {\n        if (file.mimetype.startsWith('image/')) {\n          cb(null, true);\n        } else {\n          cb(new Error('Only images are allowed'), false);\n        }\n      },\n    },\n  },\n})\nasync uploadFile({}, file?: Express.Multer.File) {\n  // Handle file\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"-routers-as-controllers",children:"\ud83c\udfa8 Routers as Controllers"}),"\n",(0,t.jsx)(n.h3,{id:"are-routers-nestjs-controllers",children:"Are routers NestJS controllers?"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Yes!"})," Routers are NestJS controllers under the hood. This means:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["They accept all NestJS controller parameter decorators (",(0,t.jsx)(n.code,{children:"@Req()"}),", ",(0,t.jsx)(n.code,{children:"@Res()"}),", ",(0,t.jsx)(n.code,{children:"@Headers()"}),", ",(0,t.jsx)(n.code,{children:"@Body()"}),", etc.)"]}),"\n",(0,t.jsxs)(n.li,{children:["Routes can have guard and pipe decorators (",(0,t.jsx)(n.code,{children:"@UseGuards()"}),", ",(0,t.jsx)(n.code,{children:"@UsePipes()"}),", ",(0,t.jsx)(n.code,{children:"@UseInterceptors()"}),", etc.) just like native NestJS controllers"]}),"\n",(0,t.jsx)(n.li,{children:"They work with dependency injection, interceptors, and all NestJS features"}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.strong,{children:["They MUST be registered in the module's ",(0,t.jsx)(n.code,{children:"controllers"})," array"]})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"do-i-need-to-register-routers-in-the-module",children:"Do I need to register routers in the module?"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Yes, absolutely!"})," Routers are controllers, so they must be in the ",(0,t.jsx)(n.code,{children:"controllers"})," array:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@Module({\n  controllers: [UserRouter], // \u2705 REQUIRED\n})\nexport class AppModule {}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"-custom-decorators",children:"\ud83c\udfa8 Custom Decorators"}),"\n",(0,t.jsx)(n.h3,{id:"can-i-create-custom-parameter-decorators",children:"Can I create custom parameter decorators?"}),"\n",(0,t.jsxs)(n.p,{children:["Yes, use ",(0,t.jsx)(n.code,{children:"createRouterParamDecorator"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { createRouterParamDecorator } from '@nestjs-rpc/server';\nimport { ExecutionContext } from '@nestjs/common';\n\nconst CurrentUser = createRouterParamDecorator(\n  (data: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    return request.user; // From your auth middleware\n  }\n);\n\n@Router()\nexport class UserRouter {\n  @Route()\n  async getProfile(\n    {}, // \u2705 First param still reserved for input\n    @CurrentUser() user: User, // \u2705 Custom decorator\n  ) {\n    return user;\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"-client-configuration",children:"\ud83d\udcbb Client Configuration"}),"\n",(0,t.jsx)(n.h3,{id:"should-i-import-the-manifest-object-or-just-the-type",children:"Should I import the manifest object or just the type?"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Always import the type only!"})," Use ",(0,t.jsx)(n.code,{children:"import type { Manifest }"})," from the server. Do ",(0,t.jsx)(n.strong,{children:"NOT"})," import the manifest object itself, as this will cause the frontend to try to evaluate backend code and result in errors:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Correct: Import type only\nimport type { Manifest } from '../server/nest-rpc.config';\n\n// \u274c Wrong: Importing the object will cause errors\nimport { manifest } from '../server/nest-rpc.config'; // DON'T DO THIS\n"})}),"\n",(0,t.jsx)(n.h2,{id:"\ufe0f-configuration",children:"\u2699\ufe0f Configuration"}),"\n",(0,t.jsx)(n.h3,{id:"how-do-i-change-the-api-prefix",children:"How do I change the API prefix?"}),"\n",(0,t.jsxs)(n.p,{children:["Set it in ",(0,t.jsx)(n.code,{children:"nestRpcInit()"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"nestRpcInit(manifest, { apiPrefix: 'api/v1' });\n"})}),"\n",(0,t.jsx)(n.p,{children:"And match it on the client:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const client = new RpcClient<Manifest>({\n  baseUrl: 'http://localhost:3000',\n  apiPrefix: 'api/v1',\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"can-i-use-different-base-urls-for-different-environments",children:"Can I use different base URLs for different environments?"}),"\n",(0,t.jsx)(n.p,{children:"Yes, use environment variables:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const client = new RpcClient<Manifest>({\n  baseUrl: import.meta.env.VITE_API_URL ?? 'http://localhost:3000',\n  apiPrefix: 'nestjs-rpc',\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"can-i-update-the-client-configuration-at-runtime",children:"Can I update the client configuration at runtime?"}),"\n",(0,t.jsxs)(n.p,{children:["Yes, use ",(0,t.jsx)(n.code,{children:"$setConfig()"})," or ",(0,t.jsx)(n.code,{children:"$setConfigProperty()"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Update single property\nclient.$setConfigProperty('baseUrl', 'https://api.production.com');\n\n// Update entire config\nclient.$setConfig({\n  baseUrl: 'https://api.production.com',\n  requestOptions: {\n    headers: {\n      Authorization: `Bearer ${newToken}`,\n    },\n  },\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"-nestjs-integration",children:"\ud83d\udd27 NestJS Integration"}),"\n",(0,t.jsx)(n.h3,{id:"do-routers-work-with-nestjs-dependency-injection",children:"Do routers work with NestJS dependency injection?"}),"\n",(0,t.jsx)(n.p,{children:"Yes! Routers are NestJS controllers, so you can use dependency injection:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@Router()\nexport class UserRouter {\n  constructor(\n    private readonly userService: UserService,\n    private readonly db: DatabaseService,\n  ) {}\n\n  @Route()\n  async getUserById(id: string) {\n    return this.userService.findById(id);\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"can-i-use-guards-interceptors-and-pipes",children:"Can I use guards, interceptors, and pipes?"}),"\n",(0,t.jsx)(n.p,{children:"Yes! Routers are standard NestJS controllers:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@Router()\n@UseGuards(AuthGuard)\n@UseInterceptors(LoggingInterceptor)\nexport class UserRouter {\n  @Route()\n  @UsePipes(ValidationPipe)\n  async createUser(input: CreateUserDto) {\n    return this.userService.create(input);\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"why-must-nestrpcinit-be-called-before-nestfactorycreate",children:["Why must ",(0,t.jsx)(n.code,{children:"nestRpcInit()"})," be called before ",(0,t.jsx)(n.code,{children:"NestFactory.create()"}),"?"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"nestRpcInit()"})," applies Nest decorators (",(0,t.jsx)(n.code,{children:"@Controller()"}),", ",(0,t.jsx)(n.code,{children:"@Post()"}),", etc.) to your router classes. NestJS needs these decorators to be present when it discovers controllers during app creation. Calling it after ",(0,t.jsx)(n.code,{children:"NestFactory.create()"})," means the decorators won't be applied in time."]}),"\n",(0,t.jsx)(n.h2,{id:"\ufe0f-react-query-integration",children:"\u269b\ufe0f React Query Integration"}),"\n",(0,t.jsx)(n.h3,{id:"should-i-use-react-query-or-direct-rpc-calls",children:"Should I use React Query or direct RPC calls?"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"For React applications, React Query is highly recommended"})," because it provides:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Automatic caching and background refetching"}),"\n",(0,t.jsx)(n.li,{children:"Automatic cache invalidation after mutations"}),"\n",(0,t.jsx)(n.li,{children:"Built-in loading and error states"}),"\n",(0,t.jsx)(n.li,{children:"Optimistic updates support"}),"\n",(0,t.jsx)(n.li,{children:"Better user experience"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Use direct RPC calls when:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You're not using React"}),"\n",(0,t.jsx)(n.li,{children:"You need fine-grained control over request timing"}),"\n",(0,t.jsx)(n.li,{children:"You're building a simple app without complex state management needs"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"how-do-i-set-up-react-query-with-nestrpc",children:"How do I set up React Query with NestRPC?"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Install dependencies:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"npm install @nestjs-rpc/query @tanstack/react-query\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:["Wrap your app with ",(0,t.jsx)(n.code,{children:"QueryClientProvider"}),":"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { QueryClient, QueryClientProvider } from '@tanstack/react-query';\n\nconst queryClient = new QueryClient();\n\nfunction App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      {/* Your app */}\n    </QueryClientProvider>\n  );\n}\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsx)(n.li,{children:"Use the hooks:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { createRpcQuery, createRpcMutation } from '@nestjs-rpc/query';\n\nconst useUserList = createRpcQuery(rpc.user.queries.listUsers);\nconst useCreateUser = createRpcMutation(rpc.user.mutations.createUser, {\n  invalidate: [rpc.user.queries.listUsers],\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["See the ",(0,t.jsx)(n.a,{href:"/docs/query/overview",children:"React Query Integration"})," guide for complete documentation."]}),"\n",(0,t.jsx)(n.h3,{id:"how-does-automatic-cache-invalidation-work",children:"How does automatic cache invalidation work?"}),"\n",(0,t.jsxs)(n.p,{children:["When you specify ",(0,t.jsx)(n.code,{children:"invalidate"})," in mutation options, the hook automatically invalidates all queries matching those routes after a successful mutation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const useCreateUser = createRpcMutation(rpc.user.mutations.createUser, {\n  invalidate: [rpc.user.queries.listUsers],\n});\n\n// After successful mutation, all queries for rpc.user.queries.listUsers are invalidated\n// This triggers a refetch if those queries are currently being used\n"})}),"\n",(0,t.jsx)(n.h3,{id:"can-i-use-file-uploads-with-react-query-mutations",children:"Can I use file uploads with React Query mutations?"}),"\n",(0,t.jsx)(n.p,{children:"Yes! File uploads work seamlessly:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const mutation = useRpcMutation(rpc.files.uploadFile);\n\nmutation.mutate({\n  body: { description: 'My file' },\n  file: fileInput.files[0],\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{href:"/docs/query/mutations",children:"Mutation Hooks"})," for details."]}),"\n",(0,t.jsx)(n.h3,{id:"how-do-i-manually-invalidate-queries",children:"How do I manually invalidate queries?"}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"useInvalidateRpcQuery"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { useInvalidateRpcQuery } from '@nestjs-rpc/query';\n\nfunction RefreshButton() {\n  const invalidate = useInvalidateRpcQuery();\n  \n  return (\n    <button onClick={() => invalidate(rpc.user.queries.listUsers)}>\n      Refresh\n    </button>\n  );\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"-troubleshooting",children:"\ud83d\udc1b Troubleshooting"}),"\n",(0,t.jsx)(n.h3,{id:"routes-are-not-being-registered",children:"Routes are not being registered"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Check initialization order"}),": ",(0,t.jsx)(n.code,{children:"nestRpcInit()"})," must be called ",(0,t.jsx)(n.strong,{children:"before"})," ",(0,t.jsx)(n.code,{children:"NestFactory.create()"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Check module registration"}),": Router classes must be in the module's ",(0,t.jsx)(n.code,{children:"controllers"})," array"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Check decorators"}),": Classes must have ",(0,t.jsx)(n.code,{children:"@Router()"})," and methods must have ",(0,t.jsx)(n.code,{children:"@Route()"})]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"type-inference-not-working-on-client",children:"Type inference not working on client"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Check manifest export"}),": Make sure you export ",(0,t.jsx)(n.code,{children:"export type Manifest = typeof manifest"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Check import"}),": Make sure the client imports the correct ",(0,t.jsx)(n.code,{children:"Manifest"})," type"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Check TypeScript"}),": Ensure TypeScript can resolve the type (may need path mapping)"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"file-uploads-not-working",children:"File uploads not working"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Check decorator"}),": Make sure ",(0,t.jsx)(n.code,{children:"@Route({ file: 'single' })"})," or ",(0,t.jsx)(n.code,{children:"@Route({ file: 'multiple' })"})," is used"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Check parameter order"}),": First param = input, second param = file/files"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Check client call"}),": Make sure you pass ",(0,t.jsx)(n.code,{children:"{ file }"})," or ",(0,t.jsx)(n.code,{children:"{ files }"})," as second parameter"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"cors-errors",children:"CORS errors"}),"\n",(0,t.jsx)(n.p,{children:"Enable CORS on your NestJS app:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"app.enableCors({\n  origin: 'http://localhost:5173',\n  credentials: true,\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"-further-reading",children:"\ud83d\udcda Further Reading"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/quick-start",children:"Quick Start"})," - Get started quickly"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/server/overview",children:"Server Overview"})," - Server concepts"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/client/overview",children:"Client Overview"})," - Client concepts"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/best-practices",children:"Best Practices"})," - Recommended patterns"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>l});var s=r(6540);const t={},i=s.createContext(t);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);